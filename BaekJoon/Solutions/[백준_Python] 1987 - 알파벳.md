## 문제

세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.

말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.

좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.

---

## 입력

첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1 ≤ R,C ≤ 20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다.

---

## 출력

첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.

---

## 풀이

```python
import sys
input = sys.stdin.readline
print = sys.stdout.write

r, c = map(int, input().split())
board = [list(input()) for _ in range(r)]

di = [-1, 0, 1, 0]
dj = [0, -1, 0, 1]

search_q = set()
search_q.add((0, 0, board[0][0]))

dist = -1

while search_q:
    cur_i, cur_j, cur_path = bfs_q.pop()
    dist = max(dist, len(cur_path))
    if dist == 26:
        break

    for a in range(4):
        next_i = cur_i + di[a]
        next_j = cur_j + dj[a]
        if 0 <= next_i < r and 0 <= next_j < c and board[next_i][next_j] not in cur_path:
            search_q.add((next_i, next_j, cur_path + board[next_i][next_j]))


print(str(dist))
```

세로 R칸, 가로 C칸의 보드에서 각 칸에 대문자 알파벳이 적혀있을 때 (0, 0)칸에서 출발하여 알파벳을 중복에서 지나지 않고 이동할 수 있는 최대거리를 구하는 문제입니다.

참으로 파이썬의 속도 한계를 다시금 느낀 문제였습니다. 처음에는 깊이 우선 탐색(DFS)를 사용하여 최대 거리를 갱신하는 방법으로 사용했으나 계속된 시간초과로 고치고 고쳐서 현재 코드까지 왔습니다. 깊이 우선 탐색의 경우 아마도 Pypy3가 아닌 python으로는 시간 제한 때문에 불가능할 것으로 보입니다. 코드는 이 블로그를 참고했습니다.

먼저 깊이 우선 탐색의 한계를 느끼고 너비 우선 탐색으로 deque를 사용하여 구현했으나 마찬가지로 시간 초과... 그래서 우선 탐색이 아닌 그냥 탐색을 사용하여 set 자료형에 방문할 정점들을 저장하고 방문할 때마다 최대 길이를 비교하여 갱신하는 방법을 사용했습니다. 이 때 set 자료형에는 방문할 정점의 좌표와 방문할 때까지의 이동한 정보를 가지고 있어야하기 때문에 정점 좌표에 추가로 지금까지 방문한 알파벳들을 문자열 형태로 저장하였습니다. 그리고 알파벳이 총 26자이기 때문에 이동거리의 최대값은 26으로 최대거리가 26이 되었을 땐 추가로 탐색하지 말고 탐색을 중단하도록 처리했습니다.

깊이 우선 탐색의 경우 시간 초과 나는게 이해는 되는데, 너비 우선 탐색에서 왜 시간 초과가 났는지 잘 모르겠습니다... deque도 set과 마찬가지로 append와 pop의 연산 속도가 O(1)이라고 알고 있는데 어떤 차이가 있는지 해당 부분 차이 하나로 시간 초과와 맞았습니다.가 결정이 되네요. 파이썬이 참 편리하면서도 이럴 때보면 쓰는게 맞나 하는 생각이 듭니다.

